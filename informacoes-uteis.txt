kill -9 PID mata qualquer processo, flask nao morre facil

netstat -tulnp | grep :5003   verificar qual processo esta na porta

criou um api-flask.service em /etc/systemd/system para poder iniciar gunicorn facil

gunicorn --bind 0.0.0.0:5003 wsgi:app inicia o gunicorn

chmod ugo+rwx foldername to give read, write, and execute to everyone.

journalctl -u api-flask ajuda a ver porque o serviço nao sobe

chmod -R a+rwx directory dá acesso completo ao folder e a tudo dentro dele pro owner

/usr/local/bin/gunicorn --bind 0.0.0.0:5003 wsgi:app

 chmod ugo+rwx /usr/local/bin/gunicorn

chown new-owner filename muda o dono de um arquivo, necessario de vez em quando, principalmente quando copia e move arquivo em sudo

sudo systemctl enable meuservico serve para fazer com que o serviço seja ativado sempre que o linux bootar

-Foi necessario dar permissao total no gunicorn em /usr/local/bin, colocar o /bin/bash no script, dar permissao de execucao pro script, e arrumar o arquivo .service exatamente como esta la, chamando oscript, ams com o environment apontando para o gunicorn, que iriamos usar. Muito chato.

-Esse comando seria melhor para performance (acesso via arquivo): gunicorn --workers 3 --bind unix:app.sock -m 007 wsgi:app

Maior problema comum parece ser, de fato, conseguir que o serviço criado em systemd/system funcione adequadamente. Por
causa disso, dê preferencia por chamar scripts de lá, assim, voce reduz os problemas gerais para o ambito de permissionamento.

https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uswgi-and-nginx-on-ubuntu-18-04-pt

https://medium.com/faun/deploy-flask-app-with-nginx-using-gunicorn-7fda4f50066a


##########RESUMO DO PROCESSO DE PUBLICAÇÃO#############
-Criar uma aplicação flask
-Testar o funcionamento rodando "pytohn3 script.py"
-Se funcionou, instale gunicorn "pip3 install gunicorn"
-Teste subir o servidor com o gunicorn dentro da pasta
-Se deu certo e funciona, crie um script bash que suba o servidor para você e teste.
-Se deu certo, crie uma arquivo .service na pasta /etc/systemd/system conforme o usado e teste se o
comando "service nome.service start", se der errado, use "service nome.service status" e tente descobrir
como resolver
-Quando resolver, configure o nginx para direcionar o caminho para sua porta no arquivo
/etc/nginx/sites-available/default
-Restarte o serviço nginx, se der errado, olhe o status e veja o porque.
-Existem a opção de o gunicorn gerar um app.sock na pasta e o nginx comunicar-se com ele usando
esse arquivo, ai voce configura o redirecionamento nao para a porta, mas para esse arquivo. Nesse caso,
o acesso não passa pela pilha de rede e provavelmente será mais performático. Talvez, no caso médio,
nao seja necessário, mas se precisar, você sabe dessa possibilidade.

